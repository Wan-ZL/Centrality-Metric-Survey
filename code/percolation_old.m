function PC = percolation(G_graph,graph_matrix)
% Dynamic Influence centrality Metrics
%       Input: G_graph, the graph structure generated by Matlab function 'G=graph()'.
%              graph_matrix, adjacency matrices
% 
%       Output: DIC, Dynamic Influence centrality value for all nodes
%       
%       Author: Zelin Wan
% 
%       Reference: 
%                   Mahendra Piraveenan, Mikhail Prokopenko, Liaquat Hossain
%                   Percolation Centrality: Quantifying Graph-Theoretic Impact of Nodes during Percolation in Networks 
%                   http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0053095
% 
%                   https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.percolation_centrality.html


node_number = length(graph_matrix);
PC = zeros(node_number,1);

sigma = ones(node_number,1);      
                % Since the 'shortestpath' function only return one shortest
                % path even if there exist more than one shortest path, sigma for all nodes set as 1.
                % An improve can be made if any other function support
                % multishort path.
                
states = ones(node_number,1);  % states not given. Assuming all nodes states are 1.

p_sigma_x_t = 0;            % sum of all percolation states

for v = 1:length(states)
    p_sigma_x_t = p_sigma_x_t + states(v);
end


for s = 1:node_number        % for all node in graph
    Short_dis = zeros(node_number,1);   % shortest distance for current node to all nodes
    predecessor = zeros(node_number,1); % the previous node of shortest path to current node
%     disp(s);
    for t = 1:node_number
        
        
         [P,d] = shortestpath(G_graph,s,t);

         Short_dis(t) = d;
            
         
         if length(P) >= 2
             predecessor(t) = P(length(P)-1);
         else
             predecessor(t) = 0;    % zero means no connection to source node.
         end

         

        % accumulate percolation
         delta = zeros(node_number,1);
         for w = 1:node_number
             coeff = (1+delta(w))/sigma(w);
             
             for v = 1:length(predecessor)
                 
                 if predecessor(v)~=0                    % skip the no edge condition 
                     delta(predecessor(v)) = delta(predecessor(v)) + (sigma(predecessor(v)) * coeff);
                 end
                 
             end
             
             if w~=s        % percolation weight
                 pw_s_w = states(s) / (p_sigma_x_t - states(w));
                 PC(w) = PC(w) + ((delta(w) * pw_s_w));
                 
             end
             
             
         end
        % end accumlate
            
    end

    
    
end
         for v = 1:length(PC)
             PC(v) = PC(v) / (node_number-2);   
         end
% PC = PC;
% disp(PC);
end


